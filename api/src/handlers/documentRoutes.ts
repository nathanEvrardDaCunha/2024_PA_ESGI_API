import express, {NextFunction, Request, Response} from "express";import {	createDocument, createZipFromDocuments, CustomDocument,	getAllDocument,	getDocumentById,	getDocumentsByUser,	updateDocument, updateFolderPaths, updatePersonDocument} from "../repository/documentRepository";import {prisma} from "../index";import {DocumentRequest, DocumentUpdateValidation, DocumentValidation} from "./validators/document-validation";import {LoginPersonRequest} from "./validators/person-validation";import { authenticateUser} from "./middleware/auth-middleware";const documentRouter = express.Router();async function checkPermissions(req: Request, res: Response, next: NextFunction) {	let userId = (req as any).userId;	const documentId = req.params.id;	const document = await prisma.document.findUnique({		where: { id: documentId },		include: { groups: { include: { members: true } }, author: true },	});	if (!document) {		return res.status(404).json({ error: 'Document not found' });	}	const isAuthorized = document.authorId === userId || document.groups.some(group => group.members.some(member => member.personId === userId));	if (isAuthorized) {		next();	} else {		res.status(403).json({ error: 'Access denied' });	}}documentRouter.get('/', async (req: Request, res: Response) => {	//TODO : Check all argument validation	//TODO : Write the service rules		try {		const document = await getAllDocument();		res.status(200).json(document);	} catch (error) {		console.error('Error fetching documents:', error);		res.status(500).json({error: 'Internal Server Error'});	}});export const getDocumentsByFolderPath = async (userId: string, folderPath: string): Promise<CustomDocument[]> => {	try {		const personDocuments = await prisma.personDocument.findMany({			where: {				personId: userId,				path: {					startsWith: folderPath,				},			},			include: {				document: true,			},		});		const documents = personDocuments.map(pd => ({			id: pd.document.id,			title: pd.document.title,			creationDate: pd.document.creationDate,			lastModified: pd.document.lastModified,			type: pd.document.type,			description: pd.document.description,			accessLevel: pd.document.accessLevel,			version: pd.document.version,			status: pd.document.status,			fileUrl: pd.document.fileUrl,			authorId: pd.document.authorId,			path: pd.path, // Include the path from PersonDocument		}));		for (const doc of documents) {			console.log(" folderPath:"+folderPath+" document:"+doc.path);			//	folderPath:/new document:/new/doc2			//  folderPath:/new document:/new/maj2/doc2		}		return documents;	} catch (error) {		console.error('Error fetching documents:', error);		throw new Error('Could not fetch documents');	}};documentRouter.get('/folder/:folderPath/download', async (req: Request, res: Response) => {	try {		const { folderPath } = req.params;		const decodedFolderPath = decodeURIComponent(folderPath);		const userId = req.headers['user-id'] as string; // Assuming userId is passed in headers		console.log(`Download request for folder: ${decodedFolderPath} by user: ${userId}`);		const documents = await getDocumentsByFolderPath(userId, decodedFolderPath);		await createZipFromDocuments(documents, res, decodedFolderPath.split('/').pop()!);	} catch (error) {		console.error('Error downloading folder:', error);		res.status(500).json({ error: 'Internal Server Error' });	}});documentRouter.post('/', async (req: Request, res: Response) => {	console.log(req.body);	const validationResult = DocumentValidation.validate(req.body);	if (validationResult.error) {		return res.status(400).json({ error: validationResult.error.details[0].message });	}	try {		const documentRequest = validationResult.value as DocumentRequest;		console.log(documentRequest);		const newDocument = await createDocument(documentRequest);		res.status(201).json(newDocument);	} catch (error) {		console.error('Error creating document:', error);		if (error instanceof Error) {			console.error('Error creating document:', error.message);			if (error.message === 'Missing required fields') {				res.status(400).json({ error: 'Missing required fields' });			} else {				res.status(500).json({ error: 'Internal Server Error', message: error.message });			}		} else {			res.status(500).json({ error: 'Internal Server Error' });		}	}});documentRouter.get('/user/:userId', async (req: Request, res: Response) => {	const { userId } = req.params;	try {		const documents=await getDocumentsByUser(userId);		res.status(200).json(documents);	} catch (error) {		console.error('Error fetching user documents:', error);		res.status(500).json({ error: 'Internal Server Error' });	}});// Route pour accéder à un document avec vérification des permissionsdocumentRouter.get('/:id',authenticateUser, checkPermissions, async (req: Request, res: Response) => {	let userId = (req as any).userId;	const { error } = DocumentValidation.validate(req.body);	if (error) {		return res.status(400).json({ error: error.details[0].message });	}	const documentId = req.params.id;	try {		const document = await prisma.document.findUnique({ where: { id: documentId } });		if (!document) {			return res.status(404).json({ error: 'Document not found' });		}		res.status(200).json(document);	} catch (error) {		console.error('Error fetching document:', error);		res.status(500).json({ error: 'Internal Server Error' });	}});documentRouter.patch('/:documentId/path', async (req: Request, res: Response) => {	// TODO: Check all argument validation	// TODO: Write the service rules	try {		const { documentId } = req.params;		const { personId, path} = req.body;		console.log(documentId);		const updatedDocument = await updatePersonDocument(documentId,personId, path);		if (!updatedDocument) {			return res.status(404).json({ error: 'Document not found' });		}		res.status(200).json(updatedDocument);	} catch (error) {		console.error('Error updating document:', error);		res.status(500).json({ error: 'Internal Server Error' });	}});documentRouter.patch('/folders/:path(*)', async (req: Request, res: Response) => {	const { path } = req.params;	const { newPath } = req.body;	if (!newPath) {		return res.status(400).json({ error: 'New path is required' });	}	try {		await updateFolderPaths(path, newPath);		res.status(200).json({ message: 'Folder paths updated successfully' });	} catch (error) {		console.error('Error updating folder paths:', error);		res.status(500).json({ error: 'Internal Server Error' });	}});documentRouter.patch('/:id', async (req: Request, res: Response) => {	// TODO: Check all argument validation	// TODO: Write the service rules		try {		const { id } = req.params;		const updatedDocument = await updateDocument(id, req.body);				if (!updatedDocument) {			return res.status(404).json({ error: 'Document not found' });		}				res.status(200).json(updatedDocument);	} catch (error) {		console.error('Error updating document:', error);		res.status(500).json({ error: 'Internal Server Error' });	}});export default documentRouter;